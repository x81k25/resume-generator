# Standard library imports
from concurrent.futures import ThreadPoolExecutor, wait, ALL_COMPLETED
import json
import os
import pickle
import re

# Third-party imports
import ast
from docx import Document
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.shared import Pt, Inches, RGBColor
from dotenv import dotenv_values
import yaml

# internal imports
from src.utils.single_content_completion import complete_single_content
from src.utils.logger import log
from src.utils.json_verifier import is_array_of_strings
from src.utils.json_verifier import is_array_of_objects
from src.utils.json_verifier import is_object

# ------------------------------------------------------------------------------
# define primary class
# ------------------------------------------------------------------------------

class GeneratedResume:
    """
    This class is used to generate a resume based on a job description and a list of experiences
    :param job_description: load the job description data
    :param role_title_overrides: a list of role titles to override the ones generated by the model
    :param model_config: configuration file that holds model specific information
    """
    def __init__(
        self,
        job_description=None,
        role_title_overrides=None,
        model_config=None,
    ):
        log("initializing GeneratedResume object")
        # ingested file parameters
        self.env_vars = dotenv_values(".env")
        with open('config/model_v1.3.4.yaml', 'r') as file:
            self.model_config: object = yaml.safe_load(file)
        with open('config/doc_format.yaml', 'r') as file:
            self.doc_format = yaml.safe_load(file)
        self.job_description = job_description
        self._set_gen_resume_components()
        # input parameters
        # will overwrite role titles given for each employer
        if role_title_overrides is not None:
            self.role_title_overrides = role_title_overrides
        else:
            self.role_title_overrides = [None] * len(self.professional_experience_input)
        # elements to be generated internally
        self.gen_soft_skills = None
        self.gen_tech_tools = None
        self.gen_tech_skills = None
        self.professional_experience_count = len(self.professional_experience_input)
        self.professional_experience_output = []  # will hold the final output to be given to resume writer
        log("GeneratedResume object initialized")

    def _set_gen_resume_components(self):
        try:
            if os.path.exists(self.env_vars['RESUME_INPUT_PATH']):
                with open(self.env_vars['RESUME_INPUT_PATH'], 'r') as file:
                    resume_input = json.load(file)
            else:
                with open(self.env_vars['RESUME_INPUT_PATH_SAMPLE'], 'r') as file:
                    resume_input = json.load(file)
        except Exception as e:
            raise ValueError(f"Error reading files: {e}")

        self.professional_experience_liminal = [] # will hold the intermediate data in processing created for the professional_experience_output
        self.personal_info = resume_input['personal_info']
        # aggregate experiences from all domains into a single array
        for employer in resume_input['professional_experience']:
            if 'domains' in employer:
                # Create a new array to store all experiences
                all_experience = []

                # Iterate through each domain and its experiences
                for domain_experience in employer['domains'].values():
                    # Extend the all_experience array with the domain's experiences
                    all_experience.extend(domain_experience)

                # Replace the domains object with the flattened experiences array
                employer['experience'] = all_experience

                del all_experience
                del domain_experience
                del employer
        self.professional_experience_input = resume_input['professional_experience']
        self.education = resume_input['education']
        self.military_experience = resume_input['military_experience']
        self.hard_skills = resume_input['hard_skills']
        for experience in self.professional_experience_input:
            self.professional_experience_liminal.append({"employer": experience["employer"]})

# ------------------------------------------------------------------------------
# helper functions to be used by other functions in this class
# ------------------------------------------------------------------------------

    @staticmethod
    def add_line(doc):
        """
        Add a horizontal line to the document
        :param doc:
        :return:
        """
        sections = doc.sections
        for section in sections:
            section.left_margin = Inches(1)
        p = doc.add_paragraph()
        run = p.add_run()
        run.add_picture('./data/assets/black-line.png', width=Inches(6.375))
        font = run.font
        font.size = Pt(1)
        p_format = p.paragraph_format
        p_format.left_indent = Inches(-0.03125)

# ------------------------------------------------------------------------------
# helper functions that specifically perform chat completions
# ------------------------------------------------------------------------------

    def _extract_tech_skills(self):
        """
        Extract the technical skills required within this job description
        :write: self.gen_tech_skills
        """
        log("extracting tech skills")

        # determine if role_description is populated
        if self.job_description['role_description'] is None or self.job_description['role_description'] == "":
            raise ValueError("Error: role_description is not populated")

        # extract prompt from config and insert prompt inputs
        prompt = self.model_config['tech_skills_extraction_prompt']
        prompt_inputs = {
            "role_description": self.job_description['role_description'],
            "json_form_clause":self.model_config['json_form_clause']
        }
        prompt = prompt.format_map(prompt_inputs)

        gen_tech_skills = complete_single_content(prompt)

        # convert the query result to an object, and raise error if it fails
        try:
            if not is_array_of_strings(ast.literal_eval(gen_tech_skills)):
                raise ValueError(
                    "Error: _extract_tech_skills output is not array of strings"
                    f"Output: {gen_tech_skills}"
                )
            self.gen_tech_skills = ast.literal_eval(gen_tech_skills)
        except Exception as e:
            raise ValueError(
                "Error: _extract_tech_skills output not valid json object" +
                f"Error: {e} " +
                f"Output: {gen_tech_skills}"
            )


    def _extract_tech_tools(self):
        """
        Extract the technical tools required within this job description
        :write: self.gen_tech_tools
        """
        log("extracting tech tools")

        # determine if role_description is populated
        if self.job_description['role_description'] is None or self.job_description['role_description'] == "":
            raise ValueError("Error: role_description is not populated")

        prompt =self.model_config['tech_tools_extraction_prompt']
        prompt_inputs = {
            "role_description": self.job_description['role_description'],
            "key_skills": self.job_description['key_skills'],
            "json_form_clause":self.model_config['json_form_clause']
        }
        prompt = prompt.format_map(prompt_inputs)

        gen_tech_tools = complete_single_content(prompt)

        # convert the query result to an object, and raise error if it fails
        try:
            if not is_array_of_strings(ast.literal_eval(gen_tech_tools)):
                raise ValueError(
                    "Error: _extract_tech_tools output is not array of strings"
                    f"Output: {gen_tech_tools}"
                )
            self.gen_tech_tools = ast.literal_eval(gen_tech_tools)
        except Exception as e:
            raise ValueError(
                "Error: _extract_tech_tools output not valid json object" +
                f"Error: {e} " +
                f"Output: {gen_tech_tools}"
            )


    def _extract_soft_skills(self):
        """
        Extract the soft skills required within this job description
        :write: self.gen_soft_skills
        """
        log("extracting soft skills")

        # determine if role_description is populated
        if self.job_description['role_description'] is None or self.job_description['role_description'] == "":
            raise ValueError("Error: role_description is not populated")

        prompt =self.model_config['soft_skills_extraction_prompt']
        prompt_inputs = {
            "role_description": self.job_description['role_description'],
            "json_form_clause":self.model_config['json_form_clause']
        }
        prompt = prompt.format_map(prompt_inputs)

        gen_soft_skills = complete_single_content(prompt)

        # convert the query result to an object, and raise error if it fails
        try:
            if not is_array_of_strings(ast.literal_eval(gen_soft_skills)):
                raise ValueError(
                    "Error: _extract_soft_skills output is not array of strings"
                    f"Output: {gen_soft_skills}"
                )
            self.gen_soft_skills = ast.literal_eval(gen_soft_skills)
        except Exception as e:
            raise ValueError(
                "Error: _extract_soft_skills output is not valid json object" +
                f"Error: {e} " +
                f"Output: {gen_soft_skills}"
            )


    def _select_all_relevant_experience(self, i):
        """
        Select all relevant experiences from the professional experience input
        :param i: index of the professional experience input
        :write: self.professional_experience_liminal[i]['all_relevant_experience']
        """
        log(f"selecting all relevant experience for employer {i}")

        # ensure all required data points are populated
        if self.professional_experience_input[i]['experience'] is None or self.professional_experience_input[i]['experience'] == "":
            raise ValueError("Error: role experience not populated")
        if self.gen_tech_skills is None or self.gen_tech_skills == "":
            raise ValueError("Error: tech skills not populated")
        if self.gen_tech_tools is None or self.gen_tech_tools == "":
            raise ValueError("Error: tech tools not populated")
        if self.gen_soft_skills is None or self.gen_soft_skills == "":
            raise ValueError("Error: soft skills not populated")

        prompt =self.model_config['select_all_experience_prompt']
        prompt_inputs = {
            "experience": self.professional_experience_input[i]['experience'],
            "skills": self.gen_tech_skills + self.gen_tech_tools + self.gen_soft_skills,
            "experience_count": self.model_config['experience_count'][i],
            "json_form_clause":self.model_config['json_form_clause']
        }
        prompt = prompt.format_map(prompt_inputs)

        # run query
        all_relevant_experience = complete_single_content(prompt)

        # convert the query to an object, and raise error if it fails
        try:
            if not is_array_of_objects(ast.literal_eval(all_relevant_experience)):
                raise ValueError(
                    "Error: _select_all_relevant_experience output is not array of objects"
                    f"Output: {all_relevant_experience}"
                )
            self.professional_experience_liminal[i]['all_relevant_experience'] = \
                ast.literal_eval(all_relevant_experience)
        except Exception as e:
            raise ValueError(
                "Error: _select_all_relevant_experiences output is not valid json object" +
                f"Error: {e} " +
                f"Output: {all_relevant_experience}"
            )


    def _select_most_relevant_experience(self, i):
        """
        Select the most relevant experiences from the professional experience input
        :param i: index of the professional experience input
        :write: self.professional_experience_liminal[i]['most_relevant_experience']
        """
        log(f"selecting most relevant experience for employer {i}")

        # ensure the exists of all required data points
        if self.professional_experience_liminal[i]['all_relevant_experience'] is None or self.professional_experience_liminal[i]['all_relevant_experience'] == "":
            raise ValueError("Error: all_relevant_experience not populated")

        prompt =self.model_config['select_most_relevant_experience_prompt']
        prompt_inputs = {
            "experience": self.professional_experience_input[i]['experience'],
            "skills": self.gen_tech_skills + self.gen_tech_tools + self.gen_soft_skills,
            "experience_count": self.model_config['experience_count'][i],
            "json_form_clause":self.model_config['json_form_clause']
        }
        prompt = prompt.format_map(prompt_inputs)

        # execute query
        most_relevant_experience = complete_single_content(prompt)

        # convert the query to an object, and raise error if it fails
        try:
            if not is_array_of_objects(ast.literal_eval(most_relevant_experience)):
                raise ValueError(
                    "Error: _select_most_relevant_experience output is not array of objects"
                    f"Output: {most_relevant_experience}"
                )
            self.professional_experience_liminal[i][
               'most_relevant_experience'] = \
               ast.literal_eval(most_relevant_experience)
        except Exception as e:
            raise ValueError(
               "Error: _select_most_relevant_experience output not valid json object" +
               f"Error: {e} " +
               f"Output: {most_relevant_experience}"
            )


    def _verify_experience(self, i):
        """
        Verify that the experience is contained with the original resume.json file
        :return:
        """
        log(f"verifying experience for employer {i}")

        # ensure the exists of all required data points
        if self.professional_experience_liminal[i]['most_relevant_experience'] is None or \
            self.professional_experience_liminal[i]['most_relevant_experience'] == "":
            raise ValueError("Error: most_relevant_experience not populated")

        prompt =self.model_config['verify_experience_prompt']
        prompt_inputs = {
            "original_experience": self.professional_experience_input[i]['experience'],
            "extracted_experience": self.professional_experience_liminal[i]['most_relevant_experience'],
            "skills": self.gen_tech_skills + self.gen_tech_tools + self.gen_soft_skills,
            "experience_count": self.model_config['experience_count'][i],
            "json_form_clause":self.model_config['json_form_clause']
        }
        prompt = prompt.format_map(prompt_inputs)

        # execute query
        verified_experience = complete_single_content(prompt)

        # convert the query to an object, and raise error if it fails
        try:
            if not is_array_of_objects(ast.literal_eval(verified_experience)):
                raise ValueError(
                    "Error: _verify_experience output is not an array of objects"
                    f"Output: {verified_experience}"
                )
            self.professional_experience_liminal[i][
               'verified_experience'] = \
               ast.literal_eval(verified_experience)
        except Exception as e:
            raise ValueError(
               "Error: _verify_experience output is a valid JSON object" +
               f"Error: {e} " +
               f"Output: {verified_experience}"
            )


    def _extract_hard_skills(self):
        # ensure the exists of all required data points
        log("extracting hard skills")

        for i in range(self.professional_experience_count):
            experience_liminal = self.professional_experience_liminal[i]
            # Check if key exists first, then check its value
            if 'verified_experience' not in experience_liminal or \
                experience_liminal.get('verified_experience') is None or \
                experience_liminal.get('verified_experience') == "":
                raise ValueError(
                    "Error: verified_experience not populated")

        all_experience = []

        for i in range(self.professional_experience_count):
            all_experience += self.professional_experience_liminal[i][
                                            'verified_experience']

        prompt =self.model_config['extract_hard_skills_prompt']
        prompt_inputs = {
            "experience": all_experience,
            "skills": self.gen_tech_skills + self.gen_tech_tools,
        }
        prompt = prompt.format_map(prompt_inputs)

        hard_skills = complete_single_content(prompt)

        try:
            if not is_object(ast.literal_eval(hard_skills)):
                raise ValueError(
                    "Error: _extract_hard_skills output not an object" +
                    f"Output: {hard_skills}"
                )
            hard_skills = ast.literal_eval(hard_skills)
            self.hard_skills.update(hard_skills)
        except Exception as e:
            raise ValueError(
                "Error: _extract_hard_skills output not valid json object" +
                f"Error: {e} " +
                f"Output: {hard_skills}"
            )


    def _format_experience(self, i):
        log(f"formatting experience for employer {i}")

        # ensure the exists of all required data points
        experience_liminal = self.professional_experience_liminal[i]
        # Check if key exists first, then check its value
        if 'verified_experience' not in experience_liminal or \
            experience_liminal.get('verified_experience') is None or \
            experience_liminal.get('verified_experience') == "":
            raise ValueError(
                "Error: verified_experience not populated")

        prompt =self.model_config['format_experience_prompt']
        prompt_inputs = {
            "experience": self.professional_experience_liminal[i]['verified_experience'],
            "skills": self.gen_tech_skills + self.gen_tech_tools + self.gen_soft_skills
        }
        prompt = prompt.format_map(prompt_inputs)

        # execute query
        formatted_experience = complete_single_content(prompt)

        # convert the query to an object, and raise error if it fails
        try:
            if not is_array_of_strings(ast.literal_eval(formatted_experience)):
                raise ValueError(
                    "Error: _format_experience output is not an array of strings" +
                    f"Output: {formatted_experience}"
                )
            self.professional_experience_liminal[i]['formatted_experience'] = \
                ast.literal_eval(formatted_experience)
        except Exception as e:
            raise ValueError(
                "Error: _format_experience output is not a valid json object" +
                f"Error: {e} " +
                f"Output: {formatted_experience}"
            )


    def _generate_role_title(self, i):
        """
		calls the OpenAI chat completion API and returns the title of the role
		:write: self.professional_experience_liminal[i]['role_title']
		"""
        log(f"generating role title for employer {i}")

        prompt =self.model_config['generate_role_title_prompt']
        prompt_inputs = {
            "experience": self.professional_experience_liminal[i]['formatted_experience']
        }
        prompt = prompt.format_map(prompt_inputs)

        role_title = complete_single_content(prompt)

        self.professional_experience_liminal[i]["role_title"] = role_title


# ------------------------------------------------------------------------------
# sub-functions over the over-arching generate_resume function below
#
# these functions will generally be called together, but due to API consumption
# need to be externally callable for testing
# ------------------------------------------------------------------------------

    def generate_resume_content(self):
        """
         Generates a resume based on a job description and a list of experiences
         :return:
         """
        log("generating resume content")

        # extract key skills required for the role
        with ThreadPoolExecutor() as executor:
            futures = [
                executor.submit(self._extract_tech_skills),
                executor.submit(self._extract_tech_tools),
                executor.submit(self._extract_soft_skills)
            ]
            # Wait for all to complete
            for future in futures:
                future.result()

        # select all relevant experiences based on key skills
        with ThreadPoolExecutor() as executor:
            indices = range(self.professional_experience_count)
            futures = {
                executor.submit(self._select_all_relevant_experience, i)
                for i in indices
            }

            wait(futures, return_when=ALL_COMPLETED)

            for future in futures:
                future.result()

        # select the most relevant experiences based off of the key skills
        with ThreadPoolExecutor() as executor:
            indices = range(self.professional_experience_count)
            futures = {
                executor.submit(self._select_most_relevant_experience, i)
                for i in indices
            }

            wait(futures, return_when=ALL_COMPLETED)

            for future in futures:
                future.result()

        # verify experience against ingested data source
        verify_futures = {}

        with ThreadPoolExecutor() as executor:
            # First, create all the futures explicitly with a loop
            for i in range(self.professional_experience_count):
                future = executor.submit(self._verify_experience, i)
                verify_futures[i] = future

            # Now wait for all futures to complete
            wait(verify_futures.values(), return_when=ALL_COMPLETED)

            # Check results one by one
            for i, future in verify_futures.items():
                try:
                    future.result()
                except Exception as e:
                    log(f"Error in verification step for employer {i}: {e}")
                    raise

        log("Verification process complete")

        # with ThreadPoolExecutor() as executor:
        #     indices = range(self.professional_experience_count)
        #     verify_futures = {
        #         i: executor.submit(self._verify_experience, i)
        #         for i in indices
        #     }
        #
        #     # Wait for all verifications to complete
        #     wait(verify_futures.values(), return_when=ALL_COMPLETED)
        #
        #     # Check for any exceptions
        #     for i, future in verify_futures.items():
        #         try:
        #             future.result()
        #         except Exception as e:
        #             log(f"Error in verification step for employer {i}: {e}")
        #             raise

        # extract hard skills and format experiences
        success = True  # Track if all operations completed successfully

        with ThreadPoolExecutor() as executor:
            format_futures = {
                executor.submit(self._format_experience, i)
                for i in indices
            }
            hard_skills_future = executor.submit(self._extract_hard_skills)

            wait([*format_futures, hard_skills_future],
                 return_when=ALL_COMPLETED)

            # Check results
            for future in [*format_futures, hard_skills_future]:
                try:
                    future.result()
                except Exception as e:
                    log(f"Error in formatting/hard skills extraction: {e}")
                    success = False

        if not success:
            raise RuntimeError(
                "Failed to complete formatting and hard skills extraction")

        # assign role titles for all employers
        with ThreadPoolExecutor() as executor:
            futures = []
            for i in range(len(self.professional_experience_liminal)):
                if self.role_title_overrides[i] is not None:
                    self.professional_experience_liminal[i]['role_title'] = \
                    self.role_title_overrides[i]
                else:
                    futures.append(
                        executor.submit(self._generate_role_title, i))

            wait(futures, return_when=ALL_COMPLETED)
            for future in futures:
                future.result()

        # display role_title results to user
        string_output = "Generated role titles: \n"

        for i in range(len(self.professional_experience_liminal)):
             string_output += (
                 self.professional_experience_liminal[i]['employer'] + ": " +
                 self.professional_experience_liminal[i]['role_title'] + "\n"
             )

        log(string_output.rstrip("\n"))

        # assemble the final output resume
        for i in range(len(self.professional_experience_liminal)):
             # incorporate elements from input resume
             self.professional_experience_output.append({"employer": self.professional_experience_liminal[i]["employer"]})
             self.professional_experience_output[i]['role_title'] = self.professional_experience_liminal[i]['role_title']
             self.professional_experience_output[i]['employment_start'] = self.professional_experience_input[i]['employment_start']
             self.professional_experience_output[i]['employment_end'] = self.professional_experience_input[i]['employment_end']
             self.professional_experience_output[i]['experience'] = self.professional_experience_liminal[i]['formatted_experience']

        # inform user run was successful
        log('professional_experience output stored in GeneratedResume.professional_experience_output')


    def write_resume(self):
        # use still working field to determine display of pe0 employment_end
        log("writing resume")

        if self.doc_format['currently_employed']:
            self.professional_experience_output[0]['employment_end'] = ""

        # open and format doc
        resume_doc = Document()

        section = resume_doc.sections[0]
        section.top_margin = Inches(1)
        section.bottom_margin = Inches(1)
        section.left_margin = Inches(1)
        section.right_margin = Inches(1)

        # set document styles
        # header 1; will be used for "Professional Experience", "Education", etc.
        h1_style = resume_doc.styles['Heading 1']
        h1_font = h1_style.font
        h1_font.name = self.doc_format['h1']['font_name']
        h1_font.size = Pt(self.doc_format['h1']['font_size'])
        h1_font.color.rgb = RGBColor(
            self.doc_format['h1']['font_color'][0],
            self.doc_format['h1']['font_color'][1],
            self.doc_format['h1']['font_color'][2]
        )
        h1_paragraph_format = h1_style.paragraph_format
        h1_paragraph_format.line_spacing = self.doc_format['h1']['line_spacing']
        h1_paragraph_format.space_before = Pt(0)
        h1_paragraph_format.space_after = Pt(0)

        ## normal text; will be used for all other text
        normal_style = resume_doc.styles['Normal']
        normal_font = normal_style.font
        normal_font.name = self.doc_format['normal']['font_name']
        normal_font.size = Pt(self.doc_format['normal']['font_size'])
        normal_font.color.rgb = RGBColor(
            self.doc_format['normal']['font_color'][0],
            self.doc_format['normal']['font_color'][1],
            self.doc_format['normal']['font_color'][2]
        )
        normal_paragraph_format = normal_style.paragraph_format
        normal_paragraph_format.line_spacing = self.doc_format['normal']['line_spacing']
        normal_paragraph_format.space_before = Pt(0)
        normal_paragraph_format.space_after = Pt(0)

        # sub_header formatting
        sub_header_font_size = normal_font.size
        sub_header_bold = True

        # insert either header image or text based on param
        if self.doc_format['use_image_header']:
            image_path = './data/assets/resume-header.png'
            resume_doc.add_picture(image_path, width=Inches(6.5))
        elif not self.doc_format['use_image_header']:
             # Add heading and set alignment to center
            name_line = resume_doc.add_heading(
                self.personal_info["first_name"].upper() + " " + self.personal_info["last_name"].upper(),
                level=1
            )
            name_line.alignment = WD_ALIGN_PARAGRAPH.CENTER

            # Add contact info paragraph and center it
            email_linkedin = resume_doc.add_paragraph(
                self.personal_info['email'] + "   |   " +
                self.personal_info['linkedin_url']
            )
            email_linkedin.alignment = WD_ALIGN_PARAGRAPH.CENTER

            # Add second contact info paragraph and center it
            phone_github = resume_doc.add_paragraph(
                self.personal_info['phone_number'] + "   |   " +
                self.personal_info['github_url']
            )
            phone_github.alignment = WD_ALIGN_PARAGRAPH.CENTER

        # horizontal bar
        # add_line(resume_doc)
        resume_doc.add_paragraph("")

        # professional experience
        # insert first section header or text header
        resume_doc.add_heading('PROFESSIONAL EXPERIENCE', level=1)
        self.add_line(resume_doc)

        # write text from model
        for i in range(len(self.professional_experience_output)):
            table = resume_doc.add_table(rows=1, cols=2)
            table.columns[0].width = Inches(4.5)
            table.columns[1].width = Inches(2.0)
            hdr_cells = table.rows[0].cells
            hdr_cells[0].text = self.professional_experience_output[i]['role_title'] + ", " + self.professional_experience_output[i]['employer']
            hdr_cells[1].text = self.professional_experience_output[i]['employment_start'] + "-" + self.professional_experience_output[i][
                'employment_end']
            left_paragraph = hdr_cells[0].paragraphs[0]
            left_paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT
            right_paragraph = hdr_cells[1].paragraphs[0]
            right_paragraph.alignment = WD_ALIGN_PARAGRAPH.RIGHT
            for cell in hdr_cells:
                for paragraph in cell.paragraphs:
                    for run in paragraph.runs:
                        run.font.bold = sub_header_bold
                        run.font.size = sub_header_font_size
                        run.font.name = 'Arial'
            for j in range(len(self.professional_experience_output[i]['experience'])):
                resume_doc.add_paragraph(self.professional_experience_output[i]['experience'][j],
                                         style='List Bullet')
            resume_doc.add_paragraph("")

        # other resume sections
        # education
        resume_doc.add_heading("EDUCATION", level=1)
        self.add_line(resume_doc)

        ## create table to house experience and date
        table = resume_doc.add_table(rows=1, cols=2)
        table.columns[0].width = Inches(4.5)
        table.columns[1].width = Inches(2.0)
        hdr_cells = table.rows[0].cells
        hdr_cells[0].text = (
            self.education['degree'] + ' ' +
            self.education['major'] + ', ' +
            self.education['institution']
        )
        hdr_cells[1].text = (
            self.education['education_start'] + "-" +
            self.education['education_end']
        )
        left_paragraph = hdr_cells[0].paragraphs[0]
        left_paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT
        right_paragraph = hdr_cells[1].paragraphs[0]
        right_paragraph.alignment = WD_ALIGN_PARAGRAPH.RIGHT
        for cell in hdr_cells:
            for paragraph in cell.paragraphs:
                for run in paragraph.runs:
                    run.font.bold = sub_header_bold
                    run.font.size = sub_header_font_size
                    run.font.name = 'Arial'

        ## add minor
        resume_doc.add_paragraph(
            self.education['minor'],
            style='List Bullet'
        )
        resume_doc.add_paragraph("")

        ## military experience
        resume_doc.add_heading("MILITARY EXPERIENCE", level=1)
        self.add_line(resume_doc)

        ### create table to house experience and date
        table = resume_doc.add_table(rows=1, cols=2)
        table.columns[0].width = Inches(4.5)
        table.columns[1].width = Inches(2.0)
        hdr_cells = table.rows[0].cells
        hdr_cells[0].text = (
            self.military_experience['role_title'] + ', ' +
            self.military_experience['branch']
        )
        hdr_cells[1].text = (
            self.military_experience['service_start'] + "-" +
            self.military_experience['service_end']
        )
        left_paragraph = hdr_cells[0].paragraphs[0]
        left_paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT
        right_paragraph = hdr_cells[1].paragraphs[0]
        right_paragraph.alignment = WD_ALIGN_PARAGRAPH.RIGHT
        for cell in hdr_cells:
            for paragraph in cell.paragraphs:
                for run in paragraph.runs:
                    run.font.bold = sub_header_bold
                    run.font.size = sub_header_font_size
                    run.font.name = self.doc_format['normal']['font_name']

        resume_doc.add_paragraph("")

        # hard skills
        resume_doc.add_heading("HARD SKILLS", level=1)
        self.add_line(resume_doc)

        for key, value in self.hard_skills.items():
            resume_doc.add_paragraph(
                f"{key}: {value}",
                style='List Bullet'
            )

        # build file output path and save doc
        resume_output_path = (
            f"""
            {self.env_vars['COVER_LETTER_OUTPUT_PATH']}
            {self.personal_info['first_name'].lower()}-
            {self.personal_info['last_name'].lower()}- 
            {self.job_description['name_param']}-resume.docx
            """
        )
        resume_output_path = re.sub(r'\s+', '', resume_output_path)
        resume_doc.save(resume_output_path)

        log('generated resume successfully written to: "' + resume_output_path + '"')


    # def check_qualifications(self):
    #     """
    #     This function uses the OpenAI API to compare the qualifications of a job applicant to a job description.
    #     :return:
    #     """
    #     log("checking qualifications")
    #     # instantiate client
    #
    #     # call API to assess the qualifications within the resume
    #     # start_time = time.time()
    #     # completion = client.chat.completions.create(
    #     #     model="gpt-4o",
    #     #     messages=[
    #     #         {"role": "system",
    #     #          "content": "The following json data describes the job skills of for Jeremy-Hatch: ```" + str(self.professional_experience_input) + "```"},
    #     #         {"role": "user", "content": "Follow these instructions: \
    #     #             1. Compare the qualifications of Jeremy Hatch to the following job description:" + "```" + self.job_description['role_description'] + "```" +
    #     #                                     "2. Locate areas where Jeremy Hatch's qualifications may be lacking" +
    #     #                                     "3. Return only areas where qualifications may be lacking"
    #     #          }
    #     #     ]
    #     # )
    #     # end_time = time.time()
    #     # duration = end_time - start_time
    #
    #     # write areas of improvement to areas_of_improvement.txt
    #     with open(self.env_vars['AREAS_OF_IMPROVEMENT_PATH'], "a") as file:
    #         file.write("## " + self.job_description['name_param'] + "\n")
    #         file.write(completion.choices[0].message.content)
    #         file.write("\n\n")
    #
    #     # output response to user
    #     string_output = (
    #         f"API call duration:    {duration}\n" +
    #         f"input tokens:         {completion.usage.prompt_tokens}\n" +
    #         f"output tokens:        {completion.usage.completion_tokens}\n" +
    #         f"content:              {completion.choices[0].message.content}"
    #     )
    #     log(string_output)

# ------------------------------------------------------------------------------
# primary function
# ------------------------------------------------------------------------------

    def generate_resume(self):
        #self.check_qualifications()
        self.generate_resume_content()
        self.write_resume()

# ------------------------------------------------------------------------------
# other external functions that are not part of the primary pipeline
# ------------------------------------------------------------------------------

    def pickle_resume(self):
        """
        pickle the resume object for later use
        """
        log("pickling resume object")
        resume_pickle_path = (
            f"""
            {self.env_vars['COVER_LETTER_OUTPUT_PATH']}
            {self.personal_info['first_name'].lower()}-
            {self.personal_info['last_name'].lower()}- 
            {self.job_description['name_param']}-resume.pkl
            """
        )
        resume_pickle_path = re.sub(r'\s+', '', resume_pickle_path)

        with open(resume_pickle_path, 'wb') as output:
            # noinspection PyTypeChecker
            pickle.dump(self, output)

        log('resume object successfully pickled to: "' + resume_pickle_path + '"')

# ------------------------------------------------------------------------------
# end of generated_resume.py
# ------------------------------------------------------------------------------
