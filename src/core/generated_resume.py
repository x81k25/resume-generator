# external imports
import ast
from concurrent.futures import ThreadPoolExecutor, wait, ALL_COMPLETED
from docx import Document
from docx.shared import Pt, Inches, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from dotenv import dotenv_values
import json
import os
import pickle
import yaml
# internal imports
from src.utils.single_content_completion import complete_single_content
from src.utils.logger import log

# ------------------------------------------------------------------------------
# load GeneratedResume params and data
# ------------------------------------------------------------------------------

log('loading params and data')

env_vars = dotenv_values(".env")

with open('config/model_v1.25.yaml', 'r') as file:
    model_config: object = yaml.safe_load(file)

with open('config/doc_format.yaml', 'r') as file:
    doc_format = yaml.safe_load(file)

# ingest files if needed
resume_input_path = env_vars['RESUME_INPUT_PATH']
resume_input_path_sample = env_vars['RESUME_INPUT_PATH_SAMPLE']

# logical test to determine if file is present at RESUME_INPUT_PATH
try:
    if os.path.exists(resume_input_path):
        with open(resume_input_path, 'r') as file:
            resume_input = json.load(file)
    else:
        with open(resume_input_path_sample, 'r') as file:
            resume_input = json.load(file)
except Exception as e:
    print(f"Error reading files: {e}")

log('params and data loaded')

# ------------------------------------------------------------------------------
# define primary class
# ------------------------------------------------------------------------------

class GeneratedResume:
    """
        This class is used to generate a resume based on a job description and a list of experiences
        :param job_description: load the job description data
        :param role_title_overrides: a list of role titles to override the ones generated by the model
        :param env_vars: environment variables
        :param model_config: model configuration
        :param doc_format: document formatting
        :param resume_input: the resume input data
"""
    def __init__(
        self,
        job_description=None,
        role_title_overrides=None,
        env_vars=env_vars,
        model_config=model_config,
        doc_format=doc_format,
        resume_input=resume_input
    ):
        log("initializing GeneratedResume object")
        # ingested file parameters
        self.env_vars = env_vars
        self.model_config = model_config
        self.doc_format = doc_format
        self.job_description = job_description
        self._set_gen_resume_components(resume_input)
        # input parameters
        # will overwrite role titles given for each employer
        if role_title_overrides is not None:
            self.role_title_overrides = role_title_overrides
        else:
            self.role_title_overrides = [None] * len(self.professional_experience_input)
        # # elements to be generated internally
        self.gen_soft_skills = None
        self.gen_tech_tools = None
        self.gen_tech_skills = None
        self.professional_experience_count = len(self.professional_experience_input)
        self.professional_experience_output = []  # will hold the final output to be given to resume writer
        log("GeneratedResume object initialized")

    def _set_gen_resume_components(self, resume_input):
        self.professional_experience_liminal = [] # will hold the intermediate data in processing created for the professional_experience_output
        self.personal_info = resume_input['personal_info']
        self.professional_experience_input = resume_input['professional_experience']
        self.education = resume_input['education']
        self.military_experience = resume_input['military_experience']
        self.hard_skills = resume_input['hard_skills']
        for experience in self.professional_experience_input:
            self.professional_experience_liminal.append({"employer": experience["employer"]})

# ------------------------------------------------------------------------------
# helper functions to be used by other functions in this class
# ------------------------------------------------------------------------------

    @staticmethod
    def add_line(doc):
        """
        Add a horizontal line to the document
        :param doc:
        :return:
        """
        sections = doc.sections
        for section in sections:
            section.left_margin = Inches(1)
        p = doc.add_paragraph()
        run = p.add_run()
        run.add_picture('./data/assets/black-line.png', width=Inches(6.375))
        font = run.font
        font.size = Pt(1)
        p_format = p.paragraph_format
        p_format.left_indent = Inches(-0.03125)

# ------------------------------------------------------------------------------
# helper functions that specifically perform chat completions
# ------------------------------------------------------------------------------

    def _extract_tech_skills(self):
        """
        Extract the technical skills required within this job description
        :write: self.gen_tech_skills
        """
        # determine if role_description is populated
        if self.job_description['role_description'] is None or self.job_description['role_description'] == "":
            raise ValueError("Error: role_description is not populated")

        self.gen_tech_skills = complete_single_content(
            "Extract the technical skills " +
            "required within this job description: " +
            self.job_description['role_description'] + " " +
            "Examples of technical skills I would like to caputure: " +
            "The definition of technical skills in this context does not include " +
            "languages and cloud tools per se, but what is to be done with those tools." +
            model_config['list_form_clause']
        )


    def _extract_tech_tools(self):
        """
        Extract the technical tools required within this job description
        :write: self.gen_tech_tools
        """
        # determine if role_description is populated
        if self.job_description['role_description'] is None or self.job_description['role_description'] == "":
            raise ValueError("Error: role_description is not populated")


        self.gen_tech_tools = complete_single_content(
            "Extract all technology tools, e.g. coding languages, cloud " +
            "development tools, and any specific development methodologies  " +
            "required within this job description: " +
            self.job_description['role_description'] + " " +
            model_config['list_form_clause']
        )


    def _extract_soft_skills(self):
        """
        Extract the soft skills required within this job description
        :write: self.gen_soft_skills
        """
        # determine if role_description is populated
        if self.job_description['role_description'] is None or self.job_description['role_description'] == "":
            raise ValueError("Error: role_description is not populated")

        self.gen_soft_skills = complete_single_content(
            "Extract the key soft skills from this job description:" +
            self.job_description['role_description'] +
            model_config['list_form_clause']
        )


    def _select_all_relevant_experiences(self, i):
        """
        Select all relevant experiences from the professional experience input
        :param i: index of the professional experience input
        :write: self.professional_experience_liminal[i]['all_relevant_responsibilities']
        """
        # ensure all required data points are populated
        if self.professional_experience_input[i]['responsibilities'] is None or self.professional_experience_input[i]['responsibilities'] == "":
            raise ValueError("Error: role responsibilities not populated")
        if self.gen_tech_skills is None or self.gen_tech_skills == "":
            raise ValueError("Error: tech skills not populated")
        if self.gen_tech_tools is None or self.gen_tech_tools == "":
            raise ValueError("Error: tech tools not populated")
        if self.gen_soft_skills is None or self.gen_soft_skills == "":
            raise ValueError("Error: soft skills not populated")

        # run query
        all_relevant_responsibilities = complete_single_content(
            f"""
            From this list: {str(self.professional_experience_input[i]['responsibilities'])} 
            select any of the elements that are in any way related to these skills: 
            {self.gen_tech_skills} + {self.gen_tech_tools} + {self.gen_soft_skills} . 
            At least {str(self.model_config['responsibility_count'][i])} elements must be selected. 
            {model_config['json_form_clause']}
            """
        )

        # convert the query to an object, and raise error if it fails
        try:
            self.professional_experience_liminal[i]['all_relevant_responsibilities'] = \
                ast.literal_eval(all_relevant_responsibilities)
        except Exception as e:
            raise ValueError(
                "Error: output not in expected format for dictionary conversion. " +
                f"Error: {e} " +
                f"Output: {all_relevant_responsibilities}"
            )


    def _select_most_relevant_experiences(self, i):
        """
        Select the most relevant experiences from the professional experience input
        :param i: index of the professional experience input
        :write: self.professional_experience_liminal[i]['most_relevant_responsibilities']
        """
        # ensure the exists of all required data points
        if self.professional_experience_liminal[i]['all_relevant_responsibilities'] is None or self.professional_experience_liminal[i]['all_relevant_responsibilities'] == "":
            raise ValueError("Error: all_relevant_responsibilities not populated")

        # execute query
        most_relevant_responsibilities = complete_single_content(
            f"""
            "From this list of responsibilities: 
            {str(self.professional_experience_liminal[i]['all_relevant_responsibilities'])} 
            select the 
            {str(self.model_config['responsibility_count'][i])} 
            most relevant entries that correspond to these skills: 
            {self.gen_tech_skills}  
            {self.gen_tech_tools}  
            {self.gen_soft_skills} . 
            {self.model_config['json_form_clause']}
            """
        )

        # convert the query to an object, and raise error if it fails
        try:
            self.professional_experience_liminal[i][
               'most_relevant_responsibilities'] = \
               ast.literal_eval(most_relevant_responsibilities)
        except Exception as e:
            raise ValueError(
               "Error: output not in expected format for dictionary conversion. " +
               f"Error: {e} " +
               f"Output: {most_relevant_responsibilities}"
            )

    def _format_experiences(self, i):
        # ensure the exists of all required data points
        if self.professional_experience_liminal[i]['most_relevant_responsibilities'] is None or \
            self.professional_experience_liminal[i]['most_relevant_responsibilities'] == "":
            raise ValueError(
                "Error: most_relevant_responsibilities not populated")

        # execute query
        formatted_responsibilities = complete_single_content(
            f"""
            Transform each JSON object in the provided array into resume bullet points. Each transformation should:
            1. Analyze the work accomplishment against these skill categories:
               Technical skills: {self.gen_tech_skills}
               Tools: {self.gen_tech_tools}
               Soft skills: {self.gen_soft_skills}
            
            2. Structure each bullet point as:
               * Lead with technical action verb derived from "what"
               * Include implementation details from "how" with tools in parentheses
               * State business purpose or context
               * End with original result exactly as provided
            
            3. Formatting rules:
               * Present tools in parenthetical lists: (Tool1, Tool2, Tool3)
               * Use serial commas in lists
               * No titles or context prefix for array
               * No characters outside of JSON array
               * Maintain original quantitative or qualitative result language
            
            4. Emphasis guidelines:
               * Preserve technical terminology that aligns with skill lists
               * Include tools mentioned in original when they connect to listed skills
               * Allow natural length variation based on skill density
               * Maintain original impact descriptions whether qualitative or quantitative
               * Let relative presence of skills in lists guide emphasis naturally
            
            For the following input:
            {self.professional_experience_liminal[i]['most_relevant_responsibilities']}

            Return a JSON array of strings where each string is a transformed bullet point.'''
            """
        )

        # convert the query to an object, and raise error if it fails
        try:
            self.professional_experience_liminal[i][
                'formatted_responsibilities'] = \
                ast.literal_eval(formatted_responsibilities)
        except Exception as e:
            raise ValueError(
                "Error: output not in expected format for dictionary conversion. " +
                f"Error: {e} " +
                f"Output: {formatted_responsibilities}"
            )

    def _extract_hard_skills(self):
        # ensure the exists of all required data points
        for i in range(self.professional_experience_count):
            if self.professional_experience_liminal[i]['formatted_responsibilities'] is None or \
                self.professional_experience_liminal[i]['formatted_responsibilities'] == "":
                raise ValueError(
                    "Error: formatted_responsibilities not populated")

        formatted_responsibilities: str = ""

        for i in range(self.professional_experience_count):
            formatted_responsibilities += str(self.professional_experience_liminal[i]['formatted_responsibilities']) + "\n"

        hard_skills = complete_single_content(
            f"""Extract and categorize purely technical skills from the following resume bullet points:
            
            INPUT BULLET POINTS:
            {formatted_responsibilities}
            
            INCLUDE ONLY:
            - Programming languages, frameworks, libraries
            - Software tools and platforms
            - Statistical/mathematical methods
            - Data processing techniques
            - Machine learning algorithms
            - Database technologies
            - Technical protocols and standards
            
            EXCLUDE ALL:
            - Soft skills (leadership, communication)
            - Business terms and processes
            - Project management terminology
            - Team/interpersonal terms
            
            RULES:
            1. Extract only explicitly mentioned technical terms
            2. Maintain exact technical nomenclature
            3. Group related tools with parentheses: "Python (NumPy, Pandas)"
            4. Create only technical categories
            5. Verify each term appears in source text
            6. Flag ambiguous technical terms
            7. Output must be valid JSON with categories as keys and single comma-separated strings as values
            8. No comments, notes, or additional text outside JSON structure
            
            REQUIRED CATEGORIES:
            - "Data Science & Analytics"
            - "Programming & Tools"
            - "Statistical Methods"
            - "Database & Storage"
            - "Machine Learning"
            
            FORMAT:
            {{
                "category_name": "item1, item2, item3 (sub1, sub2), item4",
                ...
            }}
            
            Return only the JSON object with no additional text or commentary.
            """
        )

        try:
            self.hard_skills = ast.literal_eval(hard_skills)
        except Exception as e:
            raise ValueError(
                "Error: output not in expected format for dictionary conversion. " +
                f"Error: {e} " +
                f"Output: {hard_skills}"
            )

    def _generate_role_title(self, i):
        """
		calls the OpenAI chat completion API and returns the title of the role
		:write: self.professional_experience_liminal[i]['role_title']
		"""
        self.professional_experience_liminal[i]["role_title"] = complete_single_content(
            f"""
            Return only one job title given the following list of responsibilities: 
            {self.professional_experience_liminal[i]['formatted_responsibilities']}
            """
        )

# ------------------------------------------------------------------------------
# sub-functions over the over-arching generate_resume function below
#
# these functions will generally be called together, but due to API consumption
# need to be externally callable for testing
# ------------------------------------------------------------------------------

    def generate_resume_content(self):
        """
         Generates a resume based on a job description and a list of experiences
         :return:
         """
        log("generating resume content")

        # extract key skills required for the role
        with ThreadPoolExecutor() as executor:
            futures = [
                executor.submit(self._extract_tech_skills),
                executor.submit(self._extract_tech_tools),
                executor.submit(self._extract_soft_skills)
            ]
            # Wait for all to complete
            for future in futures:
                future.result()

        # select all relevant experiences based on key skills
        with ThreadPoolExecutor() as executor:
            indices = range(self.professional_experience_count)
            futures = {
                executor.submit(self._select_all_relevant_experiences, i)
                for i in indices
            }

            wait(futures, return_when=ALL_COMPLETED)

            for future in futures:
                future.result()

        # select the most relevant experiences based off of the key skills
        with ThreadPoolExecutor() as executor:
            indices = range(self.professional_experience_count)
            futures = {
                executor.submit(self._select_most_relevant_experiences, i)
                for i in indices
            }

            wait(futures, return_when=ALL_COMPLETED)

            for future in futures:
                future.result()

        # format experiences
        with ThreadPoolExecutor() as executor:
            indices = range(self.professional_experience_count)
            futures = {
                executor.submit(self._format_experiences, i)
                for i in indices
            }

            wait(futures, return_when=ALL_COMPLETED)

            for future in futures:
                future.result()

        # extract hard skills
        #self._extract_hard_skills()

        # assign role titles for all employers
        for i in range(len(self.professional_experience_liminal)):
            if self.role_title_overrides[i] is not None:
                self.professional_experience_liminal[i]['role_title'] = self.role_title_overrides[i]
            else:
                self._generate_role_title(i)

        # display role_title results to user
        string_output = "Generated role titles: \n"

        for i in range(len(self.professional_experience_liminal)):
             string_output += (
                 self.professional_experience_liminal[i]['employer'] + ": " +
                 self.professional_experience_liminal[i]['role_title'] + "\n"
             )

        log(string_output.rstrip("\n"))

        # assemble the final output resume
        for i in range(len(self.professional_experience_liminal)):
             # incorporate elements from input resume
             self.professional_experience_output.append({"employer": self.professional_experience_liminal[i]["employer"]})
             self.professional_experience_output[i]['role_title'] = self.professional_experience_liminal[i]['role_title']
             self.professional_experience_output[i]['employment_start'] = self.professional_experience_input[i]['employment_start']
             self.professional_experience_output[i]['employment_end'] = self.professional_experience_input[i]['employment_end']
             self.professional_experience_output[i]['responsibilities'] = self.professional_experience_liminal[i]['formatted_responsibilities']

        # inform user run was successful
        log('professional_experience output stored in GeneratedResume.professional_experience_output')


    def write_resume(self):
        # use still working field to determine display of pe0 employment_end
        log("writing resume")

        if self.doc_format['currently_employed']:
            self.professional_experience_output[0]['employment_end'] = ""

        # open and format doc
        resume_doc = Document()

        section = resume_doc.sections[0]
        section.top_margin = Inches(1)
        section.bottom_margin = Inches(1)
        section.left_margin = Inches(1)
        section.right_margin = Inches(1)

        # set document styles
        # header 1; will be used for "Professional Experience", "Education", etc.
        h1_style = resume_doc.styles['Heading 1']
        h1_font = h1_style.font
        h1_font.name = self.doc_format['h1']['font_name']
        h1_font.size = Pt(self.doc_format['h1']['font_size'])
        h1_font.color.rgb = RGBColor(
            self.doc_format['h1']['font_color'][0],
            self.doc_format['h1']['font_color'][1],
            self.doc_format['h1']['font_color'][2]
        )
        h1_paragraph_format = h1_style.paragraph_format
        h1_paragraph_format.line_spacing = self.doc_format['h1']['line_spacing']
        h1_paragraph_format.space_before = Pt(0)
        h1_paragraph_format.space_after = Pt(0)

        ## normal text; will be used for all other text
        normal_style = resume_doc.styles['Normal']
        normal_font = normal_style.font
        normal_font.name = self.doc_format['normal']['font_name']
        normal_font.size = Pt(self.doc_format['normal']['font_size'])
        normal_font.color.rgb = RGBColor(
            self.doc_format['normal']['font_color'][0],
            self.doc_format['normal']['font_color'][1],
            self.doc_format['normal']['font_color'][2]
        )
        normal_paragraph_format = normal_style.paragraph_format
        normal_paragraph_format.line_spacing = self.doc_format['normal']['line_spacing']
        normal_paragraph_format.space_before = Pt(0)
        normal_paragraph_format.space_after = Pt(0)

        # sub_header formatting
        sub_header_font_size = normal_font.size
        sub_header_bold = True

        # insert either header image or text based on param
        if self.doc_format['use_image_header']:
            image_path = './data/assets/resume-header.png'
            resume_doc.add_picture(image_path, width=Inches(6.5))
        elif not self.doc_format['use_image_header']:
            resume_doc.add_heading(
                self.personal_info["first_name"].upper() + " " + self.personal_info["last_name"].upper(),
                level=1
            )
            resume_doc.add_paragraph(
                self.personal_info['email'] + "   |   " +
                self.personal_info['linkedin_url'] + "   |   " +
                self.personal_info['phone_number']
            )

        # horizontal bar
        # add_line(resume_doc)
        resume_doc.add_paragraph("")

        # professional experience
        # insert first section header or text header
        resume_doc.add_heading('PROFESSIONAL EXPERIENCE', level=1)
        self.add_line(resume_doc)

        # write text from model
        for i in range(len(self.professional_experience_output)):
            table = resume_doc.add_table(rows=1, cols=2)
            table.columns[0].width = Inches(4.5)
            table.columns[1].width = Inches(2.0)
            hdr_cells = table.rows[0].cells
            hdr_cells[0].text = self.professional_experience_output[i]['role_title'] + ", " + self.professional_experience_output[i]['employer']
            hdr_cells[1].text = self.professional_experience_output[i]['employment_start'] + "-" + self.professional_experience_output[i][
                'employment_end']
            left_paragraph = hdr_cells[0].paragraphs[0]
            left_paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT
            right_paragraph = hdr_cells[1].paragraphs[0]
            right_paragraph.alignment = WD_ALIGN_PARAGRAPH.RIGHT
            for cell in hdr_cells:
                for paragraph in cell.paragraphs:
                    for run in paragraph.runs:
                        run.font.bold = sub_header_bold
                        run.font.size = sub_header_font_size
                        run.font.name = 'Arial'
            for j in range(len(self.professional_experience_output[i]['responsibilities'])):
                resume_doc.add_paragraph(self.professional_experience_output[i]['responsibilities'][j],
                                         style='List Bullet')
            resume_doc.add_paragraph("")

        # other resume sections
        # education
        resume_doc.add_heading("EDUCATION", level=1)
        self.add_line(resume_doc)

        ## create table to house experience and date
        table = resume_doc.add_table(rows=1, cols=2)
        table.columns[0].width = Inches(4.5)
        table.columns[1].width = Inches(2.0)
        hdr_cells = table.rows[0].cells
        hdr_cells[0].text = (
            self.education['degree'] + ' ' +
            self.education['major'] + ', ' +
            self.education['institution']
        )
        hdr_cells[1].text = (
            self.education['education_start'] + "-" +
            self.education['education_end']
        )
        left_paragraph = hdr_cells[0].paragraphs[0]
        left_paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT
        right_paragraph = hdr_cells[1].paragraphs[0]
        right_paragraph.alignment = WD_ALIGN_PARAGRAPH.RIGHT
        for cell in hdr_cells:
            for paragraph in cell.paragraphs:
                for run in paragraph.runs:
                    run.font.bold = sub_header_bold
                    run.font.size = sub_header_font_size
                    run.font.name = 'Arial'

        ## add minor
        resume_doc.add_paragraph(
            self.education['minor'],
            style='List Bullet'
        )
        resume_doc.add_paragraph("")

        ## military experience
        resume_doc.add_heading("MILITARY EXPERIENCE", level=1)
        self.add_line(resume_doc)

        ### create table to house experience and date
        table = resume_doc.add_table(rows=1, cols=2)
        table.columns[0].width = Inches(4.5)
        table.columns[1].width = Inches(2.0)
        hdr_cells = table.rows[0].cells
        hdr_cells[0].text = (
            self.military_experience['role_title'] + ', ' +
            self.military_experience['branch']
        )
        hdr_cells[1].text = (
            self.military_experience['service_start'] + "-" +
            self.military_experience['service_end']
        )
        left_paragraph = hdr_cells[0].paragraphs[0]
        left_paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT
        right_paragraph = hdr_cells[1].paragraphs[0]
        right_paragraph.alignment = WD_ALIGN_PARAGRAPH.RIGHT
        for cell in hdr_cells:
            for paragraph in cell.paragraphs:
                for run in paragraph.runs:
                    run.font.bold = sub_header_bold
                    run.font.size = sub_header_font_size
                    run.font.name = self.doc_format['normal']['font_name']

        resume_doc.add_paragraph("")

        # hard skills
        resume_doc.add_heading("HARD SKILLS", level=1)
        self.add_line(resume_doc)

        for key, value in self.hard_skills.items():
            resume_doc.add_paragraph(
                f"{key}: {value}",
                style='List Bullet'
            )

        # build file output path and save doc
        resume_output_path = (
            self.env_vars['RESUME_OUTPUT_PATH'] +
            self.job_description['name_param'] +
            self.personal_info['first_name'].lower() + "-" +
            self.personal_info['last_name'].lower() + "-" +
            '-resume.docx'
        )
        resume_doc.save(resume_output_path)

        log('generated resume successfully written to: "' + resume_output_path + '"')


    # def check_qualifications(self):
    #     """
    #     This function uses the OpenAI API to compare the qualifications of a job applicant to a job description.
    #     :return:
    #     """
    #     log("checking qualifications")
    #     # instantiate client
    #
    #     # call API to assess the qualifications within the resume
    #     # start_time = time.time()
    #     # completion = client.chat.completions.create(
    #     #     model="gpt-4o",
    #     #     messages=[
    #     #         {"role": "system",
    #     #          "content": "The following json data describes the job skills of for Jeremy-Hatch: ```" + str(self.professional_experience_input) + "```"},
    #     #         {"role": "user", "content": "Follow these instructions: \
    #     #             1. Compare the qualifications of Jeremy Hatch to the following job description:" + "```" + self.job_description['role_description'] + "```" +
    #     #                                     "2. Locate areas where Jeremy Hatch's qualifications may be lacking" +
    #     #                                     "3. Return only areas where qualifications may be lacking"
    #     #          }
    #     #     ]
    #     # )
    #     # end_time = time.time()
    #     # duration = end_time - start_time
    #
    #     # write areas of improvement to areas_of_improvement.txt
    #     with open(self.env_vars['AREAS_OF_IMPROVEMENT_PATH'], "a") as file:
    #         file.write("## " + self.job_description['name_param'] + "\n")
    #         file.write(completion.choices[0].message.content)
    #         file.write("\n\n")
    #
    #     # output response to user
    #     string_output = (
    #         f"API call duration:    {duration}\n" +
    #         f"input tokens:         {completion.usage.prompt_tokens}\n" +
    #         f"output tokens:        {completion.usage.completion_tokens}\n" +
    #         f"content:              {completion.choices[0].message.content}"
    #     )
    #     log(string_output)

# ------------------------------------------------------------------------------
# primary function
# ------------------------------------------------------------------------------

    def generate_resume(self):
        #self.check_qualifications()
        self.generate_resume_content()
        self.write_resume()

# ------------------------------------------------------------------------------
# other external functions that are not part of the primary pipeline
# ------------------------------------------------------------------------------

    def pickle_resume(self):
        """
        pickle the resume object for later use
        """
        log("pickling resume object")
        resume_pickle_path = (
            self.env_vars['RESUME_OUTPUT_PATH'] +
            self.job_description['name_param'] +
            self.personal_info['first_name'].lower() + "-" +
            self.personal_info['last_name'].lower() + "-" +
            '-resume.pkl'
        )
        with open(resume_pickle_path, 'wb') as output:
            pickle.dump(self, output)

        log('resume object successfully pickled to: "' + resume_pickle_path + '"')

# ------------------------------------------------------------------------------
# end of generated_resume.py
# ------------------------------------------------------------------------------
